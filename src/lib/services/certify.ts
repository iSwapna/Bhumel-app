import { contractId } from '$lib/stores/contractId';
import track from '$lib/contracts/track';
import { account, send } from '$lib/passkeyClient';
import { Address } from '@stellar/stellar-sdk';
import { get } from 'svelte/store';
import type { ToastStore } from '@skeletonlabs/skeleton';
import { keyId } from '$lib/stores/keyId';

// Steps: for certify function: generate hash off chain and emit soroban event
// 1.this function takes in a string ( the summary generated by rust-wasm-summary.ts)
// 2. get user github identity - user id, name, email
// 3. generate hash of user id + email + summary string + timestamp
// 4. call a contract function in $lib/contracts/track to generate an event with this hash and timestamp
// 5. store the hash and summary text in a cache with timestamp as key

// Steps: for verify function: verify on chain
// 1.this function takes in a string, user id and timestamp
// 2. generates the hash from the string, user id and timestamp
// 3. call a contract function in $lib/contracts/track to verify this hash is in storage and return the timestamp
// 4. If hash found, return timestamp

// steps: for generateLink function
// 1. generate a link to a page on this site anyone can access
// 2. this page will have a button to verify the text and user id
// 3. when clicked, it will call the verify function with the hash
// 4. if the hash is found, it will return the timestamp
// 5. if the hash is not found, it will return an error

interface CertifyResult {
	hash: string;
	timestamp: number;
	userId: string;
}

async function generateHash(input: string): Promise<string> {
	const encoder = new TextEncoder();
	const data = encoder.encode(input);
	const hashBuffer = await crypto.subtle.digest('SHA-256', data);
	const hashArray = Array.from(new Uint8Array(hashBuffer));
	return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
}

export async function certify(
	summary: string,
	userId: string,
	toastStore: ToastStore
): Promise<CertifyResult> {
	const timestamp = Date.now();

	// Generate hash from summary + userId + timestamp
	const hashInput = `${userId}${summary}${timestamp}`;
	const hash = await generateHash(hashInput);

	try {
		const contractIdValue = get(contractId);
		if (!contractIdValue) {
			throw new Error('Contract ID is not initialized');
		}

		const userAddress = Address.fromString(contractIdValue);
		console.log('Calling track.certify with:', {
			user: userAddress.toString(),
			hash,
			timestamp: BigInt(timestamp)
		});

		const at = await track.certify({
			user: userAddress.toString(),
			hash: hash,
			timestamp: BigInt(timestamp)
		});

		const currentKeyId = get(keyId);
		if (!currentKeyId) {
			throw new Error('Wallet not initialized. Please complete the signup process first.');
		}

		// Clean up the keyId if it has excessive escaping
		let cleanKeyId = currentKeyId;
		if (currentKeyId.length > 100) {
			console.warn('[Certify] KeyId appears to be over-escaped, attempting to clean it');
			try {
				// Try to parse it as JSON to remove extra escaping
				cleanKeyId = JSON.parse(currentKeyId);
			} catch {
				console.warn('[Certify] Failed to parse keyId as JSON, using as-is');
			}
		}

		console.log('[Certify] Using keyId:', cleanKeyId);
		console.log('[Certify] keyId type:', typeof cleanKeyId);
		console.log('[Certify] keyId length:', cleanKeyId.length);

		const txn = await account.sign(at.built!, { keyId: cleanKeyId });
		await send(txn.built!);

		toastStore.trigger({
			message: 'Recorded Transaction to Stellar.',
			background: 'variant-filled-success'
		});

		return {
			hash,
			timestamp,
			userId
		};
	} catch (err) {
		console.error('Error in certify:', err);
		toastStore.trigger({
			message: 'Something went wrong signing the guestbook. Please try again later.',
			background: 'variant-filled-error'
		});
		throw err; // Re-throw the error so the calling code knows it failed
	}
}

export async function verify(
	hash: string,
	userId: string,
	timestamp: number
): Promise<number | null> {
	// TODO: Call Rust contract function (will implement later)
	// For now, just return the timestamp to use the parameters
	console.log('Verifying hash:', hash, 'for user:', userId, 'at timestamp:', timestamp);
	return timestamp;
}

export function generateLink(userId: string, hash: string): string {
	// TODO: Implement proper URL generation
	return `/verify?userId=${userId}&hash=${hash}`;
}
