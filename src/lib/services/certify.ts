import { contractId } from '$lib/stores/contractId';
import track from '$lib/contracts/track';
import type { Certificate } from 'track';
import { account, send } from '$lib/passkeyClient';
import { Address } from '@stellar/stellar-sdk';
import { get } from 'svelte/store';
import type { ToastStore } from '@skeletonlabs/skeleton';
import { keyId } from '$lib/stores/keyId';

// Steps: for certify function: generate hash off chain and emit soroban event
// 1.this function takes in a string ( the summary generated by rust-wasm-summary.ts)
// 2. get user github identity - user id, name, email
// 3. generate hash of user id + email + summary string + timestamp
// 4. call a contract function in $lib/contracts/track to generate an event with this hash and timestamp
// 5. store the hash and summary text in a cache with timestamp as key

// Steps: for verify function: verify on chain
// 1.this function takes in a string, user id and timestamp
// 2. generates the hash from the string, user id and timestamp
// 3. call a contract function in $lib/contracts/track to verify this hash is in storage and return the timestamp
// 4. If hash found, return timestamp

// steps: for generateLink function
// 1. generate a link to a page on this site anyone can access
// 2. this page will have a button to verify the text and user id
// 3. when clicked, it will call the verify function with the hash
// 4. if the hash is found, it will return the timestamp
// 5. if the hash is not found, it will return an error

interface CertifyResult {
	certificate: Certificate;
	timestamp: number;
	userId: string;
	username: string;
}

interface VerifyResult {
	certificate: Certificate;
	algorithm: string;
	lastAudited: string;
}

async function generateHash(input: string): Promise<string> {
	const encoder = new TextEncoder();
	const data = encoder.encode(input);
	const hashBuffer = await crypto.subtle.digest('SHA-256', data);
	const hashArray = Array.from(new Uint8Array(hashBuffer));
	return hashArray.map((b) => b.toString(16).padStart(2, '0')).join('');
}

export async function certify(
	summary: string,
	userId: string,
	username: string,
	toastStore: ToastStore
): Promise<CertifyResult> {
	const timestamp = Date.now();

	console.log('Certify function called with:', {
		summary: summary.substring(0, 100) + '...',
		userId,
		username,
		timestamp
	});

	// Generate hash from summary + userId + timestamp
	const hashInput = `${userId}${summary}${timestamp}`;
	const hash = await generateHash(hashInput);

	try {
		const contractIdValue = get(contractId);
		if (!contractIdValue) {
			throw new Error('Contract ID is not initialized');
		}

		const userAddress = Address.fromString(contractIdValue);
		console.log('Calling track.certify with:', {
			user: userAddress.toString(),
			id: userId,
			hash,
			timestamp: BigInt(timestamp)
		});

		const at = await track.certify({
			user: userAddress.toString(),
			id: userId,
			hash: hash,
			timestamp: BigInt(timestamp)
		});

		const currentKeyId = get(keyId);
		if (!currentKeyId) {
			throw new Error('Wallet not initialized. Please complete the signup process first.');
		}

		// Clean up the keyId if it has excessive escaping
		let cleanKeyId = currentKeyId;
		if (currentKeyId.length > 100) {
			console.warn('[Certify] KeyId appears to be over-escaped, attempting to clean it');
			try {
				cleanKeyId = JSON.parse(currentKeyId);
			} catch {
				console.warn('[Certify] Failed to parse keyId as JSON, using as-is');
			}
		}

		console.log('[Certify] Using keyId:', cleanKeyId);
		console.log('[Certify] keyId type:', typeof cleanKeyId);
		console.log('[Certify] keyId length:', cleanKeyId.length);

		const txn = await account.sign(at.built!, { keyId: cleanKeyId });
		await send(txn.built!);

		toastStore.trigger({
			message: 'Recorded Transaction to Stellar.',
			background: 'variant-filled-success'
		});

		// Add debug logging for the return value
		const result = {
			certificate: {
				hash,
				id: userId
			},
			timestamp,
			userId,
			username
		};
		console.log('Certify returning:', result);
		return result;
	} catch (err) {
		console.error('Error in certify:', err);
		toastStore.trigger({
			message: 'Something went wrong signing the guestbook. Please try again later.',
			background: 'variant-filled-error'
		});
		throw err;
	}
}

export async function verify(timestamp: number): Promise<VerifyResult | null> {
	try {
		console.log('Verifying timestamp:', timestamp);

		// Call the contract to verify the timestamp exists on the chain
		const tx = await track.verify({
			timestamp: BigInt(timestamp)
		});

		// Debug log the raw result
		console.log('tx:', tx.simulationData.result.retval.value.toString());
		// Extract the hash and id from the result
		const certificate = {
			hash: tx.result.unwrap().hash,
			id: tx.result.unwrap().id
		};

		// Add the additional metadata
		const verifyResult: VerifyResult = {
			certificate,
			algorithm: 'https://github.com/iSwapna/Bhumel-app',
			lastAudited: 'TBD'
		};

		console.log('Parsed certificate:', verifyResult);
		return verifyResult;
	} catch (err) {
		console.error('Error in verify:', err);
		throw err;
	}
}

export function generateLink(username: string, hash: string, timestamp: number): string {
	// Generate a link that includes username, hash, and timestamp for verification
	console.log('generateLink called with:', { username, hash, timestamp });
	const link = `/verify?username=${encodeURIComponent(username)}&hash=${hash}&timestamp=${timestamp}`;
	console.log('Generated link:', link);
	return link;
}
